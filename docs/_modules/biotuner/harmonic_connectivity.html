
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>biotuner.harmonic_connectivity &#8212; Biotuner 0.0.10 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/example_gallery_styles.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/thebelab-helper.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Biotuner 0.0.10 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Menu:
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../getting_started.html">
   Getting started with Biotuner
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../cite_us.html">
   Cite us
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../examples/index.html">
   Examples
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/biotuner_MNE/biotuner_MNE.html">
     Harmonicity Metrics Computation on MNE Epochs File
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/peaks_extraction/peaks_extraction.html">
     Peaks extraction methods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/harmonicity_metrics/harmonicity_metrics.html">
     Harmonicity metrics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/harmonic_spectrum/harmonic_spectrum.html">
     From Spectral Peaks to Harmonic Spectrum Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/toolbox_paper_notebook/toolbox_paper_notebook.html">
     Biotuner Paper Design and Implementation Examples
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/toolbox_paper_result_notebook/toolbox_paper_result_notebook.html">
     Biotuner Toolbox Paper Results Figures
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/scale_construction/scale_construction.html">
     Constructing musical tunings with biosignals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/spectral_chords/spectral_chords.html">
     Deriving spectral chords from biosignals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/rhythm_construction/rhythm_construction.html">
     Constructing euclidian rhythms from biotunings
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/phase_amplitude_coupling/phase_amplitude_coupling.html">
     Phase-Amplitude Coupling
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../api/index.html">
   API
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/biotuner_object.html">
     Biotuner object
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
    <label for="toctree-checkbox-3">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/metrics.html">
     Harmonicity Metrics
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/peaks_extraction.html">
     Peaks Extraction
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/peaks_extension.html">
     Peaks Extension
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
    <label for="toctree-checkbox-6">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/harmonic_spectrum.html">
     Harmonic spectrum
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/harmonic_connectivity.html">
     Harmonic connectivity
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
    <label for="toctree-checkbox-8">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/transitional_harmony.html">
     Transitional Harmony
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
    <label for="toctree-checkbox-9">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/scale_construction.html">
     Scale construction
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
    <label for="toctree-checkbox-10">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/rhythm_construction.html">
     Rhythm construction
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
    <label for="toctree-checkbox-11">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/utils.html">
     Biotuner utilities
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
    <label for="toctree-checkbox-12">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for biotuner.harmonic_connectivity</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">biotuner.biotuner_object</span> <span class="kn">import</span> <span class="n">compute_biotuner</span>
<span class="kn">from</span> <span class="nn">biotuner.metrics</span> <span class="kn">import</span> <span class="n">ratios2harmsim</span><span class="p">,</span> <span class="n">compute_subharmonics_2lists</span><span class="p">,</span> <span class="n">euler</span><span class="p">,</span> <span class="n">dyad_similarity</span>
<span class="kn">from</span> <span class="nn">biotuner.biotuner_utils</span> <span class="kn">import</span> <span class="n">rebound_list</span><span class="p">,</span> <span class="n">butter_bandpass_filter</span>
<span class="kn">from</span> <span class="nn">biotuner.peaks_extension</span> <span class="kn">import</span> <span class="n">harmonic_fit</span>
<span class="kn">from</span> <span class="nn">biotuner.transitional_harmony</span> <span class="kn">import</span> <span class="n">transitional_harmony</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">hilbert</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">zscore</span><span class="p">,</span> <span class="n">t</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sbn</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mutual_info_score</span>
<span class="c1">#import pywt</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="kn">from</span> <span class="nn">statsmodels.stats.multitest</span> <span class="kn">import</span> <span class="n">multipletests</span>
<span class="kn">from</span> <span class="nn">mne.viz</span> <span class="kn">import</span> <span class="n">circular_layout</span>
<span class="c1">#from mne_connectivity.viz import plot_connectivity_circle</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">PyEMD</span> <span class="kn">import</span> <span class="n">EMD</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">hilbert</span><span class="p">,</span> <span class="n">coherence</span><span class="p">,</span> <span class="n">welch</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">biotuner.metrics</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">dyad_similarity</span><span class="p">,</span>
    <span class="n">compute_subharmonic_tension</span><span class="p">,</span>
    <span class="n">ratios2harmsim</span><span class="p">,</span>
    <span class="n">peaks_to_harmsim</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">biotuner.harmonic_spectrum</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">compute_frequency_and_psd</span><span class="p">,</span>
    <span class="n">compute_resonance_values</span><span class="p">,</span>
    <span class="n">find_spectral_peaks</span><span class="p">,</span>
    <span class="n">harmonic_entropy</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">biotuner.biotuner_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">safe_mean</span><span class="p">,</span>
    <span class="n">safe_max</span><span class="p">,</span>
    <span class="n">apply_power_law_remove</span><span class="p">,</span>
    <span class="n">compute_frequency_and_psd</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">stft</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span><span class="p">,</span> <span class="n">gaussian_filter1d</span>
<span class="kn">import</span> <span class="nn">emd</span>
<span class="kn">from</span> <span class="nn">biotuner.peaks_extraction</span> <span class="kn">import</span> <span class="n">EMD_eeg</span>
 

<div class="viewcode-block" id="harmonic_connectivity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity">[docs]</a><span class="k">class</span> <span class="nc">harmonic_connectivity</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class used to compute harmonicity metrics</span>
<span class="sd">    between pairs of sensors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">peaks_function</span><span class="o">=</span><span class="s2">&quot;EMD&quot;</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">n_harm</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">harm_function</span><span class="o">=</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span>
        <span class="n">min_freq</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">max_freq</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
        <span class="n">n_peaks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sf: int</span>
<span class="sd">            sampling frequency (in Hz)</span>
<span class="sd">        data : 2D array (elec, numDataPoints)</span>
<span class="sd">            Electrodes x Time series to analyse.</span>
<span class="sd">        peaks_function: str, default=&#39;EMD&#39;</span>
<span class="sd">            See compute_biotuner class for details.</span>
<span class="sd">        precision: float, default=0.1</span>
<span class="sd">            Precision of the peaks (in Hz)</span>
<span class="sd">            When HH1D_max is used, bins are in log scale.</span>
<span class="sd">        n_harm: int, default=10</span>
<span class="sd">            Set the number of harmonics to compute in harmonic_fit function</span>
<span class="sd">        harm_function: str, default=&#39;mult&#39;</span>
<span class="sd">            Computes harmonics from iterative multiplication (x, 2x, 3x, ...nx)</span>
<span class="sd">            or division (x, x/2, x/3, ...x/n).</span>
<span class="sd">            Choose between &#39;mult&#39; and &#39;div&#39;</span>
<span class="sd">        min_freq: float, default=2</span>
<span class="sd">            Minimum frequency (in Hz) to consider for peak extraction.</span>
<span class="sd">        max_freq: float, default=80</span>
<span class="sd">            Maximum frequency (in Hz) to consider for peak extraction.</span>
<span class="sd">        n_peaks: int, default=5</span>
<span class="sd">            Number of peaks to extract per frequency band.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf</span> <span class="o">=</span> <span class="n">sf</span>
        <span class="c1"># Initializing arguments for peak extraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span> <span class="o">=</span> <span class="n">peaks_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span> <span class="o">=</span> <span class="n">n_harm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">harm_function</span> <span class="o">=</span> <span class="n">harm_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span> <span class="o">=</span> <span class="n">min_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_freq</span> <span class="o">=</span> <span class="n">max_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span> <span class="o">=</span> <span class="n">n_peaks</span>

<div class="viewcode-block" id="harmonic_connectivity.compute_harm_connectivity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.compute_harm_connectivity">[docs]</a>    <span class="k">def</span> <span class="nf">compute_harm_connectivity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span><span class="p">,</span>
        <span class="n">delta_lim</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">savename</span><span class="o">=</span><span class="s2">&quot;_&quot;</span><span class="p">,</span>
        <span class="n">graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_denom_rrci</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the harmonic connectivity matrix between electrodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metric : str, optional</span>
<span class="sd">            The metric to use for computing harmonic connectivity. Default is &#39;harmsim&#39;.</span>
<span class="sd">            </span>
<span class="sd">            Possible values are:</span>

<span class="sd">             - &#39;harmsim&#39;: </span>
<span class="sd">                computes the harmonic similarity between each pair of peaks from the two electrodes.</span>
<span class="sd">                It calculates the ratio between each pair of peaks and computes the mean harmonic similarity.</span>

<span class="sd">             - &#39;euler&#39;:</span>
<span class="sd">                computes the Euler&#39;s Gradus Suavitatis on the concatenated peaks of the two electrodes.</span>

<span class="sd">             - &#39;harm_fit&#39;:</span>
<span class="sd">                computes the number of common harmonics between each pair of peaks from the two electrodes.</span>
<span class="sd">                It evaluates the harmonic fit between each peak pair and counts the number of common harmonics.</span>

<span class="sd">             - &#39;subharm_tension&#39;:</span>
<span class="sd">                computes the tension between subharmonics of two electrodes.</span>
<span class="sd">                It evaluates the tension between subharmonics of the two electrodes by comparing the subharmonics and their ratios.</span>

<span class="sd">             - &#39;RRCi&#39;:</span>
<span class="sd">                computes the Rhythmic Ratio Coupling with Imaginary Component (RRCi) metric between each pair of</span>
<span class="sd">                peaks from the two electrodes, using a bandwidth of 2 Hz and a max_denom of 16. This metric calculates the</span>
<span class="sd">                imaginary part of the complex phase differences between two filtered signals.</span>

<span class="sd">             - &#39;wPLI_crossfreq&#39;:</span>
<span class="sd">                computes the weighted Phase Lag Index (wPLI) for cross-frequency coupling between each pair</span>
<span class="sd">                of peaks from the two electrodes. The wPLI measures the phase synchronization between two signals, with a value</span>
<span class="sd">                close to 0 indicating no synchronization and a value close to 1 indicating perfect synchronization.</span>

<span class="sd">             - &#39;wPLI_multiband&#39;:</span>
<span class="sd">                computes the weighted Phase Lag Index (wPLI) for multiple frequency bands between the two electrodes.</span>
<span class="sd">                It calculates wPLI for each frequency band and returns an array of wPLI values for the defined frequency bands.</span>

<span class="sd">        delta_lim : int, optional</span>
<span class="sd">            The delta limit for the subharmonic tension metric. Default is 20.</span>

<span class="sd">        save : bool, optional</span>
<span class="sd">            Whether to save the connectivity matrix. Default is False.</span>

<span class="sd">        savename : str, optional</span>
<span class="sd">            The name to use when saving the connectivity matrix. Default is &#39;_&#39;.</span>

<span class="sd">        graph : bool, optional</span>
<span class="sd">            Whether to display a heatmap of the connectivity matrix. Default is True.</span>
<span class="sd">            </span>
<span class="sd">        FREQ_BANDS : list, optional</span>
<span class="sd">            The frequency bands to use for the computation of the wPLI_multiband metric. Default is None.</span>
<span class="sd">            If None, the following frequency bands will be used: [2, 3.55], [3.55, 7.15], [7.15, 14.3], [14.3, 28.55], [28.55, 49.4].</span>
<span class="sd">            </span>
<span class="sd">        max_denom_rrci : int, optional</span>
<span class="sd">            The maximum denominator to use for the computation of the RRCi metric. Default is 16.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conn_matrix : numpy.ndarray</span>
<span class="sd">            The harmonic connectivity matrix between electrodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize biotuner object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">list_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">list_idx</span><span class="p">,</span> <span class="n">list_idx</span><span class="p">))</span>
        <span class="n">harm_conn_matrix</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">FREQ_BANDS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">FREQ_BANDS</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.55</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">3.55</span><span class="p">,</span> <span class="mf">7.15</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">7.15</span><span class="p">,</span> <span class="mf">14.3</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">14.3</span><span class="p">,</span> <span class="mf">28.55</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">28.55</span><span class="p">,</span> <span class="mf">49.4</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;wPLI_multiband&quot;</span><span class="p">:</span>
            <span class="n">harm_conn_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">FREQ_BANDS</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
            <span class="n">data1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">data2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># if i % (len(pairs) // 10) == 0:</span>
            <span class="n">percentage_complete</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
            <span class="c1">#print(f&quot;{percentage_complete}% complete&quot;)</span>
            <span class="n">bt1</span> <span class="o">=</span> <span class="n">compute_biotuner</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">peaks_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">n_harm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">bt1</span><span class="o">.</span><span class="n">peaks_extraction</span><span class="p">(</span>
                <span class="n">data1</span><span class="p">,</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">max_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_freq</span><span class="p">,</span>
                <span class="n">max_harm_freq</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
                <span class="n">n_peaks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">smooth_fft</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="n">FREQ_BANDS</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">list1</span> <span class="o">=</span> <span class="n">bt1</span><span class="o">.</span><span class="n">peaks</span>
            <span class="n">bt2</span> <span class="o">=</span> <span class="n">compute_biotuner</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">peaks_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">n_harm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">bt2</span><span class="o">.</span><span class="n">peaks_extraction</span><span class="p">(</span>
                <span class="n">data2</span><span class="p">,</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">max_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_freq</span><span class="p">,</span>
                <span class="n">max_harm_freq</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
                <span class="n">n_peaks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">smooth_fft</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="n">FREQ_BANDS</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">list2</span> <span class="o">=</span> <span class="n">bt2</span><span class="o">.</span><span class="n">peaks</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;subharm_tension&quot;</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">common_subs</span><span class="p">,</span>
                    <span class="n">delta_t</span><span class="p">,</span>
                    <span class="n">sub_tension_final</span><span class="p">,</span>
                    <span class="n">harm_temp</span><span class="p">,</span>
                    <span class="n">pairs_melody</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">compute_subharmonics_2lists</span><span class="p">(</span>
                    <span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="n">delta_lim</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">2.1</span>
                <span class="p">)</span>
                <span class="c1">#print(sub_tension_final)</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_tension_final</span><span class="p">)</span>
            <span class="c1"># compute the harmonic similarity between each pair of peaks from the two electrodes.</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;harmsim&quot;</span><span class="p">:</span>
                <span class="n">harm_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">))</span>
                <span class="n">ratios</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">harm_pairs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ratios</span> <span class="o">=</span> <span class="n">rebound_list</span><span class="p">(</span><span class="n">ratios</span><span class="p">)</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratios2harmsim</span><span class="p">(</span><span class="n">ratios</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;RRCi&quot;</span><span class="p">:</span>
                <span class="n">rrci_values</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">peak1</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">peak2</span> <span class="ow">in</span> <span class="n">list2</span><span class="p">:</span>
                        <span class="n">rrci_value</span> <span class="o">=</span> <span class="n">cross_frequency_rrci</span><span class="p">(</span>
                            <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span> <span class="n">peak1</span><span class="p">,</span> <span class="n">peak2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_denom_rrci</span>
                        <span class="p">)</span>
                        <span class="n">rrci_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rrci_value</span><span class="p">)</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rrci_values</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;euler&quot;</span><span class="p">:</span>
                <span class="n">list_all</span> <span class="o">=</span> <span class="n">list1</span> <span class="o">+</span> <span class="n">list2</span>
                <span class="n">list_all</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_all</span><span class="p">]</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">euler</span><span class="p">(</span><span class="o">*</span><span class="n">list_all</span><span class="p">))</span>

            <span class="c1"># to do</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;if metric == &#39;PPC_bicor&#39;:</span>
<span class="sd">                list_all = list1 + list2</span>
<span class="sd">                list_all = [int(x*10) for x in list_all]</span>
<span class="sd">                harm_conn_matrix.append(euler(*list_all))&quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;harm_fit&quot;</span><span class="p">:</span>
                <span class="n">harm_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">))</span>
                <span class="n">harm_fit</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">harm_pairs</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">harmonic_fit</span><span class="p">(</span>
                        <span class="n">p</span><span class="p">,</span>
                        <span class="n">n_harm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span>
                        <span class="n">bounds</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                        <span class="n">function</span><span class="o">=</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span>
                        <span class="n">div_mode</span><span class="o">=</span><span class="s2">&quot;div&quot;</span><span class="p">,</span>
                        <span class="n">n_common_harms</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">harm_fit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">harm_fit</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;wPLI_crossfreq&quot;</span><span class="p">:</span>
                <span class="n">wPLI_values</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">peak1</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">peak2</span> <span class="ow">in</span> <span class="n">list2</span><span class="p">:</span>
                        <span class="n">wPLI_value</span> <span class="o">=</span> <span class="n">wPLI_crossfreq</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">peak1</span><span class="p">,</span> <span class="n">peak2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">)</span>
                        <span class="n">wPLI_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wPLI_value</span><span class="p">)</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wPLI_values</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;wPLI_multiband&quot;</span><span class="p">:</span>
                <span class="n">wPLI_values</span> <span class="o">=</span> <span class="n">wPLI_multiband</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">FREQ_BANDS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wPLI_values</span><span class="p">):</span>
                    <span class="n">harm_conn_matrix</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;MI&quot;</span><span class="p">:</span>
                <span class="n">bandwidth</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">MI_values</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">peak1</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">peak2</span> <span class="ow">in</span> <span class="n">list2</span><span class="p">:</span>
                        <span class="c1"># Filter the original signals using the frequency bands</span>
                        <span class="n">filtered_signal1</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span>
                            <span class="n">data1</span><span class="p">,</span> <span class="n">peak1</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">peak1</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
                        <span class="p">)</span>
                        <span class="n">filtered_signal2</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span>
                            <span class="n">data2</span><span class="p">,</span> <span class="n">peak2</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">peak2</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
                        <span class="p">)</span>

                        <span class="c1"># Compute the instantaneous phase of each signal using the Hilbert transform</span>
                        <span class="n">analytic_signal1</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">))</span>
                        <span class="n">analytic_signal2</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal2</span><span class="p">))</span>
                        <span class="n">phase1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal1</span><span class="p">)</span>
                        <span class="n">phase2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal2</span><span class="p">)</span>

                        <span class="c1"># Compute Mutual Information</span>
                        <span class="n">MI_value</span> <span class="o">=</span> <span class="n">compute_mutual_information</span><span class="p">(</span><span class="n">phase1</span><span class="p">,</span> <span class="n">phase2</span><span class="p">)</span>
                        <span class="n">MI_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MI_value</span><span class="p">)</span>

                        <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">MI_values</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;MI_spectral&quot;</span><span class="p">:</span>
                <span class="c1"># Create the pairs of peaks</span>
                <span class="n">peak_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">))</span>

                <span class="c1"># Compute the average MI value for the pairs of peaks</span>
                <span class="n">avg_mi</span> <span class="o">=</span> <span class="n">MI_spectral</span><span class="p">(</span>
                    <span class="n">data1</span><span class="p">,</span>
                    <span class="n">data2</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_freq</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                    <span class="n">peak_pairs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">avg_mi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;wPLI_multiband&quot;</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">harm_conn_matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">harm_conn_matrix</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
        <span class="c1"># conn_matrix = matrix.astype(&#39;float&#39;)</span>
        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">sbn</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
            <span class="c1"># Add title and axis names</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Harmonic connectivity matrix (</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn_matrix</span> <span class="o">=</span> <span class="n">matrix</span>
        <span class="k">return</span> <span class="n">matrix</span> </div>


<div class="viewcode-block" id="harmonic_connectivity.compute_IMF_correlation"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.compute_IMF_correlation">[docs]</a>    <span class="k">def</span> <span class="nf">compute_IMF_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nIMFs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">freq_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the correlation, coherence, and peak frequency between each pair of IMFs for each pair of electrodes.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : pd.DataFrame</span>
<span class="sd">            DataFrame with columns: elec1, elec2, imf1, imf2, pearson, coherence, and peak_freq.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">num_electrodes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Pre-compute IMFs for each electrode</span>
        <span class="n">all_IMFs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">peak_frequencies</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Store peak frequencies for each IMF</span>

        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_electrodes</span><span class="p">):</span>
            <span class="n">IMFs</span> <span class="o">=</span> <span class="n">EMD_eeg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">elec</span><span class="p">,</span> <span class="p">:],</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;EMD&quot;</span><span class="p">)</span>
            <span class="n">IMFs</span> <span class="o">=</span> <span class="n">IMFs</span><span class="p">[:</span><span class="n">nIMFs</span><span class="p">]</span>
            <span class="n">all_IMFs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">IMFs</span><span class="p">)</span>

            <span class="c1"># Compute peak frequencies for each IMF once</span>
            <span class="n">elec_peak_freqs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">imf</span> <span class="ow">in</span> <span class="n">IMFs</span><span class="p">:</span>
                <span class="n">f_welch</span><span class="p">,</span> <span class="n">Pxx</span> <span class="o">=</span> <span class="n">welch</span><span class="p">(</span><span class="n">imf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="o">/</span><span class="n">precision</span><span class="p">))</span>
                <span class="n">peak_freq</span> <span class="o">=</span> <span class="n">f_welch</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Pxx</span><span class="p">)]</span>
                <span class="n">elec_peak_freqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak_freq</span><span class="p">)</span>
            <span class="n">peak_frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elec_peak_freqs</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;shape all IMFS&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_IMFs</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        
        <span class="c1"># Iterate over pairs of electrodes</span>
        <span class="k">for</span> <span class="n">elec1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_electrodes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">elec2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_electrodes</span><span class="p">):</span>
                <span class="n">num_IMFs_elec1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_IMFs</span><span class="p">[</span><span class="n">elec1</span><span class="p">])</span>
                <span class="n">num_IMFs_elec2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_IMFs</span><span class="p">[</span><span class="n">elec2</span><span class="p">])</span>
                
                <span class="c1"># Compute correlation and coherence between IMFs of the two electrodes</span>
                <span class="k">for</span> <span class="n">imf1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_IMFs_elec1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">imf2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_IMFs_elec2</span><span class="p">):</span>
                        <span class="n">corr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">all_IMFs</span><span class="p">[</span><span class="n">elec1</span><span class="p">][</span><span class="n">imf1</span><span class="p">],</span> <span class="n">all_IMFs</span><span class="p">[</span><span class="n">elec2</span><span class="p">][</span><span class="n">imf2</span><span class="p">])</span>
                        <span class="n">f</span><span class="p">,</span> <span class="n">Cxy</span> <span class="o">=</span> <span class="n">coherence</span><span class="p">(</span><span class="n">all_IMFs</span><span class="p">[</span><span class="n">elec1</span><span class="p">][</span><span class="n">imf1</span><span class="p">],</span> <span class="n">all_IMFs</span><span class="p">[</span><span class="n">elec2</span><span class="p">][</span><span class="n">imf2</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">)</span>
                        
                        <span class="c1"># Filter for desired frequency range</span>
                        <span class="n">filtered_coherence</span> <span class="o">=</span> <span class="n">Cxy</span><span class="p">[(</span><span class="n">f</span> <span class="o">&gt;=</span> <span class="n">freq_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;=</span> <span class="n">freq_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                        <span class="n">mean_coherence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">filtered_coherence</span><span class="p">)</span>
                        
                        <span class="c1"># Retrieve the precomputed peak frequency for the IMF</span>
                        <span class="n">peak_freq1</span> <span class="o">=</span> <span class="n">peak_frequencies</span><span class="p">[</span><span class="n">elec1</span><span class="p">][</span><span class="n">imf1</span><span class="p">]</span>
                        <span class="n">peak_freq2</span> <span class="o">=</span> <span class="n">peak_frequencies</span><span class="p">[</span><span class="n">elec2</span><span class="p">][</span><span class="n">imf2</span><span class="p">]</span>

                        <span class="n">peak1</span> <span class="o">=</span> <span class="n">peak_frequencies</span><span class="p">[</span><span class="n">elec1</span><span class="p">][</span><span class="n">imf1</span><span class="p">]</span>
                        <span class="n">peak2</span> <span class="o">=</span> <span class="n">peak_frequencies</span><span class="p">[</span><span class="n">elec2</span><span class="p">][</span><span class="n">imf2</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">peak1</span> <span class="o">&gt;=</span> <span class="n">peak2</span><span class="p">:</span>
                            <span class="n">harmsim</span> <span class="o">=</span> <span class="n">dyad_similarity</span><span class="p">(</span><span class="n">peak1</span><span class="o">/</span><span class="n">peak2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">peak2</span> <span class="o">&gt;</span> <span class="n">peak1</span><span class="p">:</span>
                            <span class="n">harmsim</span> <span class="o">=</span> <span class="n">dyad_similarity</span><span class="p">(</span><span class="n">peak2</span><span class="o">/</span><span class="n">peak1</span><span class="p">)</span>
                            
                        <span class="c1"># compute subharmonic tension</span>
                        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">subharm_tension</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_subharmonic_tension</span><span class="p">([</span><span class="n">peak1</span><span class="p">,</span> <span class="n">peak2</span><span class="p">],</span> <span class="n">n_harmonics</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                                                               <span class="n">delta_lim</span><span class="o">=</span><span class="n">delta_lim</span><span class="p">,</span> <span class="n">min_notes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                            <span class="s2">&quot;elec1&quot;</span><span class="p">:</span> <span class="n">elec1</span><span class="p">,</span>
                            <span class="s2">&quot;elec2&quot;</span><span class="p">:</span> <span class="n">elec2</span><span class="p">,</span>
                            <span class="s2">&quot;imf1&quot;</span><span class="p">:</span> <span class="n">imf1</span><span class="p">,</span>
                            <span class="s2">&quot;imf2&quot;</span><span class="p">:</span> <span class="n">imf2</span><span class="p">,</span>
                            <span class="s2">&quot;pearson&quot;</span><span class="p">:</span> <span class="n">corr</span><span class="p">,</span>
                            <span class="s2">&quot;coherence&quot;</span><span class="p">:</span> <span class="n">mean_coherence</span><span class="p">,</span>
                            <span class="s2">&quot;peak_freq1&quot;</span><span class="p">:</span> <span class="n">peak_freq1</span><span class="p">,</span>
                            <span class="s2">&quot;peak_freq2&quot;</span><span class="p">:</span> <span class="n">peak_freq2</span><span class="p">,</span>
                            <span class="s1">&#39;harmsim&#39;</span><span class="p">:</span> <span class="n">harmsim</span><span class="p">,</span>
                            <span class="s1">&#39;subharm_tension&#39;</span><span class="p">:</span> <span class="n">subharm_tension</span>
                        <span class="p">})</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="harmonic_connectivity.compute_time_resolved_harm_connectivity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.compute_time_resolved_harm_connectivity">[docs]</a>    <span class="k">def</span> <span class="nf">compute_time_resolved_harm_connectivity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">nIMFs</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="mi">50</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the time-resolved harmonic connectivity matrix between electrodes,</span>
<span class="sd">        which is a harmonic connectivity matrix for each intrinsic mode function (IMF),</span>
<span class="sd">        and each time point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Input data with shape (num_electrodes, numDataPoints)</span>
<span class="sd">        sf : int</span>
<span class="sd">            Sampling frequency</span>
<span class="sd">        nIMFs : int</span>
<span class="sd">            Number of intrinsic mode functions (IMFs) to consider.</span>
<span class="sd">        metric : str, optional</span>
<span class="sd">            The metric to use for computing harmonic connectivity. Default is &#39;harmsim&#39;.</span>
<span class="sd">        delta_lim : int, optional</span>
<span class="sd">            The delta limit for the subharmonic tension metric. Default is 20.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        connectivity_matrices : numpy.ndarray</span>
<span class="sd">            Time-resolved harmonic connectivity matrices with shape (IMFs, numDataPoints, electrodes, electrodes).</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        !!! This method is very computationally expensive and can take a long time to run. !!!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">num_electrodes</span><span class="p">,</span> <span class="n">numDataPoints</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">connectivity_matrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">nIMFs</span><span class="p">,</span> <span class="n">numDataPoints</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">harmonicity_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">imf</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIMFs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDataPoints</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_electrodes</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">):</span>
                        <span class="n">pair_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">pair_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">harmonicity_cache</span><span class="p">:</span>
                            <span class="n">time_series1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="n">time_series2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="n">harmonicity_cache</span><span class="p">[</span><span class="n">pair_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">EMD_time_resolved_harmonicity</span><span class="p">(</span>
                                <span class="n">time_series1</span><span class="p">,</span>
                                <span class="n">time_series2</span><span class="p">,</span>
                                <span class="n">sf</span><span class="p">,</span>
                                <span class="n">nIMFs</span><span class="o">=</span><span class="n">nIMFs</span><span class="p">,</span>
                                <span class="n">method</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                            <span class="p">)</span>

                        <span class="n">harmonicity</span> <span class="o">=</span> <span class="n">harmonicity_cache</span><span class="p">[</span><span class="n">pair_key</span><span class="p">]</span>
                        <span class="n">connectivity_matrices</span><span class="p">[</span><span class="n">imf</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">harmonicity</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span>
                        <span class="n">connectivity_matrices</span><span class="p">[</span><span class="n">imf</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">harmonicity</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">connectivity_matrices</span></div>

<div class="viewcode-block" id="harmonic_connectivity.transitional_connectivity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.transitional_connectivity">[docs]</a>    <span class="k">def</span> <span class="nf">transitional_connectivity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;win_overlap&quot;</span><span class="p">,</span>
        <span class="n">overlap</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">delta_lim</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">n_trans_harm</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function calculates the transitional connectivity among electrodes, utilizing concepts of transitional harmony and temporal correlation.</span>
<span class="sd">        It does so by employing a two-step approach:</span>

<span class="sd">        - Transitional Harmony Calculation: For every electrode, the transitional harmony is determined first.</span>
<span class="sd">                                            This measure reflects the patterns or sequences of signal transitions over time</span>
<span class="sd">                                            that each electrode experiences.</span>

<span class="sd">        - Temporal Correlation with FDR Correction: After obtaining transitional harmonies, the function evaluates the temporal correlation</span>
<span class="sd">                                                    between these harmonies for each pair of electrodes. Temporal correlation quantifies</span>
<span class="sd">                                                    how similar the timing and pattern of transitional harmonies are between each pair of electrodes.</span>

<span class="sd">        The entire process takes into account multiple comparisons, utilizing False Discovery Rate (FDR) correction</span>
<span class="sd">        to reduce the likelihood of false positives. This correction is crucial in maintaining the validity and robustness of the results,</span>
<span class="sd">        especially when dealing with a large number of comparisons, as is the case with numerous electrodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Multichannel EEG data with shape (n_electrodes, n_timepoints).</span>
<span class="sd">        sf : float</span>
<span class="sd">            Sampling frequency of the EEG data in Hz.</span>
<span class="sd">        mode : str, optional, default=&#39;win_overlap&#39;</span>
<span class="sd">            The mode to compute the transitional harmony.</span>
<span class="sd">            &#39;win_overlap&#39; computes the transitional harmony using a sliding window with overlap.</span>
<span class="sd">        overlap : int, optional, default=10</span>
<span class="sd">            The percentage of overlap between consecutive windows when computing</span>
<span class="sd">            the transitional harmony. Default is 10.</span>
<span class="sd">        delta_lim : int, optional, default=20</span>
<span class="sd">            The minimum delta value for the computation of</span>
<span class="sd">            subharmonic tension, in ms. Default is 20.</span>
<span class="sd">        graph : bool, optional, default=False</span>
<span class="sd">            If True, it will plot the graph of the transitional harmony. Default is False.</span>
<span class="sd">        n_trans_harm : int, optional, default=3</span>
<span class="sd">            Number of transitional harmonics to compute. Default is 3.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conn_mat : numpy.ndarray</span>
<span class="sd">            Connectivity matrix of shape (n_electrodes, n_electrodes) representing</span>
<span class="sd">            the transitional connectivity between electrodes.</span>
<span class="sd">        pval_mat : numpy.ndarray</span>
<span class="sd">            P-value matrix of shape (n_electrodes, n_electrodes) with FDR-corrected</span>
<span class="sd">            p-values for the computed connectivity values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">trans_subharm_tot</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_electrodes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_electrodes</span><span class="p">):</span>
            <span class="n">th</span> <span class="o">=</span> <span class="n">transitional_harmony</span><span class="p">(</span>
                <span class="n">sf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">elec</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">peaks_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">n_harm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span>
                <span class="n">harm_function</span><span class="o">=</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">max_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_freq</span><span class="p">,</span>
                <span class="n">n_peaks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">,</span>
                <span class="n">n_trans_harm</span><span class="o">=</span><span class="n">n_trans_harm</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">trans_subharm</span><span class="p">,</span> <span class="n">time_vec_final</span><span class="p">,</span> <span class="n">pairs_melody</span> <span class="o">=</span> <span class="n">th</span><span class="o">.</span><span class="n">compute_trans_harmony</span><span class="p">(</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;win_overlap&quot;</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="n">delta_lim</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span>
            <span class="p">)</span>
            <span class="n">trans_subharm_tot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trans_subharm</span><span class="p">)</span>
        <span class="n">subharm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trans_subharm_tot</span><span class="p">)</span>
        <span class="n">conn_mat</span><span class="p">,</span> <span class="n">pval_mat</span> <span class="o">=</span> <span class="n">temporal_correlation_fdr</span><span class="p">(</span><span class="n">subharm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">conn_mat</span><span class="p">,</span> <span class="n">pval_mat</span><span class="p">,</span> <span class="n">subharm</span></div>

<div class="viewcode-block" id="harmonic_connectivity.plot_conn_matrix"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.plot_conn_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">plot_conn_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conn_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_lines</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots a connectivity matrix in a circle plot.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conn_matrix : ndarray, optional</span>
<span class="sd">            The connectivity matrix to plot. If None, uses the object&#39;s own attribute `conn_matrix`. </span>
<span class="sd">            If `conn_matrix` is still None, a ValueError will be raised.</span>
<span class="sd">        node_names : list, optional</span>
<span class="sd">            The labels for the nodes. If None, a range object will be converted to a list of string values for node names.</span>
<span class="sd">        n_lines : int, default=50</span>
<span class="sd">            The number of lines to draw in the plot. Default is 50.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure.Figure</span>
<span class="sd">            A matplotlib figure object.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raised when no connectivity matrix is found.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method uses the function `plot_connectivity_circle` to plot the connectivity matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">conn_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conn_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn_matrix</span>
            <span class="c1"># Raise error if conn_matrix is still None</span>
            <span class="k">if</span> <span class="n">conn_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No connectivity matrix found.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn_matrix</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">]</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_connectivity_circle</span><span class="p">(</span>
            <span class="n">conn_matrix</span><span class="p">,</span>
            <span class="n">node_names</span><span class="o">=</span><span class="n">node_names</span><span class="p">,</span>
            <span class="n">n_lines</span><span class="o">=</span><span class="n">n_lines</span><span class="p">,</span>
            <span class="n">fontsize_names</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span>
            <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="harmonic_connectivity.compute_harmonic_spectrum_connectivity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.compute_harmonic_spectrum_connectivity">[docs]</a>    <span class="k">def</span> <span class="nf">compute_harmonic_spectrum_connectivity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">power_law_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">n_peaks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span><span class="p">,</span>
        <span class="n">n_harms</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">delta_lim</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">min_notes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">smoothness</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">smoothness_harm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">phase_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">save_fig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">savename</span><span class="o">=</span><span class="s2">&quot;harmonic_spectrum_connectivity.png&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the harmonic spectrum connectivity between pairs of electrodes. For more details on the harmonic spectrum, </span>
<span class="sd">        see the function :func:`compute_cross_spectrum_harmonicity`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sf : float, optional</span>
<span class="sd">            Sampling frequency of the data. If not provided, uses the object&#39;s own attribute `sf`.</span>
<span class="sd">        data : ndarray, optional</span>
<span class="sd">            2D data array of shape (n_electrodes, n_datapoints). If not provided, uses the object&#39;s own attribute `data`.</span>
<span class="sd">        precision : float, default=0.5</span>
<span class="sd">            Precision of the frequency axis of the cross-spectrum.</span>
<span class="sd">        fmin : float, optional</span>
<span class="sd">            Minimum frequency for computation. If not provided, uses the smallest possible frequency (i.e., zero).</span>
<span class="sd">        fmax : float, optional</span>
<span class="sd">            Maximum frequency for computation. If not provided, uses the Nyquist frequency.</span>
<span class="sd">        noverlap : int, default=1</span>
<span class="sd">            Argument passed to the :func:`scipy.signal.stft` function.</span>
<span class="sd">        power_law_remove : bool, default=False</span>
<span class="sd">            If True, removes the power-law noise from the cross-spectrum.</span>
<span class="sd">        n_peaks : int, default=5</span>
<span class="sd">            Number of peaks to derive from the harmonic spectrum.</span>
<span class="sd">        metric : str, default=&#39;harmsim&#39;</span>
<span class="sd">            Name of the metric to be used in the computation of harmonicity.</span>
<span class="sd">            Choose between:</span>
<span class="sd">            </span>
<span class="sd">            - &#39;harmsim&#39;</span>
<span class="sd">            - &#39;subharm_tension&#39;</span>
<span class="sd">        n_harms : int, default=10</span>
<span class="sd">            Number of harmonics to consider in the computation.</span>
<span class="sd">        delta_lim : float, default=0.1</span>
<span class="sd">            Threshold for the delta limit used in subharmonic tension computation.</span>
<span class="sd">        min_notes : int, default=2</span>
<span class="sd">            Minimum number of notes required for a harmonic pattern to be considered valid,</span>
<span class="sd">            when subharmonic tension is used as the metric.</span>
<span class="sd">        plot : bool, default=False</span>
<span class="sd">            If True, plots the results.</span>
<span class="sd">        smoothness : int, default=1</span>
<span class="sd">            Smoothness factor of the power spectrum.</span>
<span class="sd">            When smoothness=1, no smoothing is applied.</span>
<span class="sd">        smoothness_harm : int, default=1</span>
<span class="sd">            Smoothness factor of the harmonic spectrum.</span>
<span class="sd">            When smoothness_harm=1, no smoothing is applied.</span>
<span class="sd">        phase_mode : str, optional</span>
<span class="sd">            If set to &#39;weighted&#39;, the phase coupling is weighted by the power of associated frequencies.</span>
<span class="sd">        save_fig : bool, default=False</span>
<span class="sd">            If True, saves the resulting plot as a .png file.</span>
<span class="sd">        savename : str, default=&#39;harmonic_spectrum_connectivity.png&#39;</span>
<span class="sd">            Name of the .png file to save if `save_fig` is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : pandas.DataFrame</span>
<span class="sd">            DataFrame containing the results of the harmonic spectrum connectivity computation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The harmonic spectrum connectivity is computed between each pair of electrodes. This is achieved</span>
<span class="sd">        by computing the cross-spectrum harmonicity for each pair of electrodes, and storing the results</span>
<span class="sd">        in a DataFrame. The DataFrame includes indices of the electrode pairs, alongside the results of</span>
<span class="sd">        the harmonicity computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">electrodes</span><span class="p">,</span> <span class="n">datapoints</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Will store the generated DataFrames</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">electrodes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">electrodes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">signal1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">signal2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">compute_cross_spectrum_harmonicity</span><span class="p">(</span>
                        <span class="n">signal1</span><span class="p">,</span>
                        <span class="n">signal2</span><span class="p">,</span>
                        <span class="n">precision_hz</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                        <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
                        <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span><span class="p">,</span>
                        <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                        <span class="n">fs</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span>
                        <span class="n">power_law_remove</span><span class="o">=</span><span class="n">power_law_remove</span><span class="p">,</span>
                        <span class="n">n_peaks</span><span class="o">=</span><span class="n">n_peaks</span><span class="p">,</span>
                        <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                        <span class="n">n_harms</span><span class="o">=</span><span class="n">n_harms</span><span class="p">,</span>
                        <span class="n">delta_lim</span><span class="o">=</span><span class="n">delta_lim</span><span class="p">,</span>
                        <span class="n">min_notes</span><span class="o">=</span><span class="n">min_notes</span><span class="p">,</span>
                        <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
                        <span class="n">smoothness</span><span class="o">=</span><span class="n">smoothness</span><span class="p">,</span>
                        <span class="n">smoothness_harm</span><span class="o">=</span><span class="n">smoothness_harm</span><span class="p">,</span>
                        <span class="n">phase_mode</span><span class="o">=</span><span class="n">phase_mode</span><span class="p">,</span>
                        <span class="n">save_fig</span><span class="o">=</span><span class="n">save_fig</span><span class="p">,</span>
                        <span class="n">save_name</span><span class="o">=</span><span class="n">savename</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;elec1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># Add electrode indices to DataFrame</span>
                    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;elec2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Concatenate all the dataframes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_spectrum_connectivity</span> <span class="o">=</span> <span class="n">output</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="harmonic_connectivity.get_harm_spectrum_metric_matrix"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.get_harm_spectrum_metric_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_harm_spectrum_metric_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to retrieve a matrix of harmonic spectrum metric values between pairs of electrodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metric : str</span>
<span class="sd">            The specific metric from the harmonic spectrum connectivity data to create the matrix from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matrix : pandas.DataFrame or None</span>
<span class="sd">            A pivot table with &#39;elec1&#39; and &#39;elec2&#39; as indices and the provided &#39;metric&#39; as values. </span>
<span class="sd">            If &#39;harmonic_spectrum_connectivity&#39; is None or &#39;metric&#39; is not found in &#39;harmonic_spectrum_connectivity&#39;,</span>
<span class="sd">            this method will print an error message and return None.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method checks if &#39;harmonic_spectrum_connectivity&#39; exists in the object.</span>
<span class="sd">        If it does, it further checks if &#39;metric&#39; exists in the DataFrame&#39;s columns. If both checks pass,</span>
<span class="sd">        a pivot table is created using &#39;elec1&#39; and &#39;elec2&#39; as indices and &#39;metric&#39; as values. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if self.harmonic_spectrum_connectivity exists</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_spectrum_connectivity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: No harmonic_spectrum_connectivity found.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Check if the metric exists in the DataFrame</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_spectrum_connectivity</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2"> not found in harmonic_spectrum_connectivity.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Create a pivot table with &#39;elec1&#39; and &#39;elec2&#39; as indices and &#39;metric&#39; as values</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_spectrum_connectivity</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="s2">&quot;elec1&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;elec2&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">metric</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">matrix</span></div>
    
<div class="viewcode-block" id="harmonic_connectivity.plot_IMF_correlation_matrix"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.plot_IMF_correlation_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">plot_IMF_correlation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">elec1</span><span class="p">,</span> <span class="n">elec2</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="s1">&#39;pearson&#39;</span><span class="p">,</span> <span class="n">savepath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a heatmap of correlations between IMFs for specified electrodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : pd.DataFrame</span>
<span class="sd">            DataFrame containing the correlation data with columns: elec1, elec2, imf1, imf2, and pearson.</span>
<span class="sd">        elec1 : int</span>
<span class="sd">            The first electrode of interest.</span>
<span class="sd">        elec2 : int</span>
<span class="sd">            The second electrode of interest.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Filter the dataframe for the specified electrodes</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;elec1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">elec1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;elec2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">elec2</span><span class="p">)]</span>
        
        <span class="c1"># Find the number of unique IMFs</span>
        <span class="n">num_IMFs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">[</span><span class="s1">&#39;imf1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()),</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">[</span><span class="s1">&#39;imf2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()))</span>
        
        <span class="c1"># Create an empty matrix for correlations</span>
        <span class="n">corr_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_IMFs</span><span class="p">,</span> <span class="n">num_IMFs</span><span class="p">))</span>
        
        <span class="c1"># Fill the matrix with correlation values</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">subset</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">corr_matrix</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;imf1&#39;</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;imf2&#39;</span><span class="p">])]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>

        <span class="c1"># Determine the colorbar range</span>
        <span class="n">max_corr</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_corr</span><span class="p">,</span> <span class="n">max_corr</span>
        
        <span class="c1"># Plot the heatmap</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">corr_matrix</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Correlation between IMFs for Electrode </span><span class="si">{</span><span class="n">elec1</span><span class="si">}</span><span class="s1"> and Electrode </span><span class="si">{</span><span class="n">elec2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;IMFs of Electrode </span><span class="si">{</span><span class="n">elec2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;IMFs of Electrode </span><span class="si">{</span><span class="n">elec1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">savepath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">savepath</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="wPLI_crossfreq"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.wPLI_crossfreq">[docs]</a><span class="k">def</span> <span class="nf">wPLI_crossfreq</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">peak1</span><span class="p">,</span> <span class="n">peak2</span><span class="p">,</span> <span class="n">sf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the weighted phase lag index (wPLI) between two signals in specified frequency bands, centered around</span>
<span class="sd">    provided peak frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal1 : ndarray</span>
<span class="sd">        First signal in time series.</span>
<span class="sd">    signal2 : ndarray</span>
<span class="sd">        Second signal in time series.</span>
<span class="sd">    peak1 : float</span>
<span class="sd">        Center of the frequency band for the first signal.</span>
<span class="sd">    peak2 : float</span>
<span class="sd">        Center of the frequency band for the second signal.</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wPLI : float</span>
<span class="sd">        Weighted phase lag index between two signals in specified frequency bands.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; signal1 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; signal2 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; peak1 = 10.0</span>
<span class="sd">    &gt;&gt;&gt; peak2 = 20.0</span>
<span class="sd">    &gt;&gt;&gt; sf = 100.0</span>
<span class="sd">    &gt;&gt;&gt; wPLI = wPLI_crossfreq(signal1, signal2, peak1, peak2, sf)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define a band around each peak</span>
    <span class="n">bandwidth</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># You can adjust the bandwidth as needed</span>

    <span class="c1"># Filter the original signals using the frequency bands</span>
    <span class="n">filtered_signal1</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span>
        <span class="n">signal1</span><span class="p">,</span> <span class="n">peak1</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">peak1</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sf</span>
    <span class="p">)</span>
    <span class="n">filtered_signal2</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span>
        <span class="n">signal2</span><span class="p">,</span> <span class="n">peak2</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">peak2</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sf</span>
    <span class="p">)</span>

    <span class="c1"># Compute the wPLI between the filtered signals</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">)</span>
    <span class="n">analytic_signal1</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">))</span>
    <span class="n">analytic_signal2</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal2</span><span class="p">))</span>

    <span class="n">phase_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal2</span><span class="p">)</span>
    <span class="n">wPLI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_diff</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">wPLI</span></div>


<div class="viewcode-block" id="wPLI_multiband"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.wPLI_multiband">[docs]</a><span class="k">def</span> <span class="nf">wPLI_multiband</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">freq_bands</span><span class="p">,</span> <span class="n">sf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the weighted phase lag index (wPLI) between two signals for multiple frequency bands.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal1 : ndarray</span>
<span class="sd">        First signal in time series.</span>
<span class="sd">    signal2 : ndarray</span>
<span class="sd">        Second signal in time series.</span>
<span class="sd">    freq_bands : list of tuple</span>
<span class="sd">        List of frequency bands. Each band is represented as a tuple (lowcut, highcut).</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wPLI_values : list of float</span>
<span class="sd">        List of wPLI values for each frequency band.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; signal1 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; signal2 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; freq_bands = [(8, 12), (13, 30), (30, 70)]</span>
<span class="sd">    &gt;&gt;&gt; sf = 100.0</span>
<span class="sd">    &gt;&gt;&gt; wPLI_values = wPLI_multiband(signal1, signal2, freq_bands, sf)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wPLI_values</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">freq_bands</span><span class="p">:</span>
        <span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span> <span class="o">=</span> <span class="n">band</span>

        <span class="c1"># Filter the original signals using the frequency bands</span>
        <span class="n">filtered_signal1</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>
        <span class="n">filtered_signal2</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span><span class="n">signal2</span><span class="p">,</span> <span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>

        <span class="c1"># Compute the wPLI between the filtered signals</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">)</span>
        <span class="n">analytic_signal1</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">))</span>
        <span class="n">analytic_signal2</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal2</span><span class="p">))</span>

        <span class="n">phase_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal2</span><span class="p">)</span>
        <span class="n">wPLI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_diff</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">wPLI</span><span class="p">)</span>
        <span class="n">wPLI_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wPLI</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wPLI_values</span></div>

<div class="viewcode-block" id="n_m_phase_locking"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.n_m_phase_locking">[docs]</a><span class="k">def</span> <span class="nf">n_m_phase_locking</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">sf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate n:m phase locking between two signals.</span>
<span class="sd">    </span>
<span class="sd">    :param signal1: First time series.</span>
<span class="sd">    :param signal2: Second time series.</span>
<span class="sd">    :param n: Multiplicative factor for the first signal.</span>
<span class="sd">    :param m: Multiplicative factor for the second signal.</span>
<span class="sd">    :param sf: Sampling frequency of the signals.</span>
<span class="sd">    :return: Mean resultant length (Rn:m) indicating the phase locking value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the instantaneous phase for each signal using the Hilbert transform</span>
    <span class="n">phase1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">hilbert</span><span class="p">(</span><span class="n">signal1</span><span class="p">))</span>
    <span class="n">phase2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">hilbert</span><span class="p">(</span><span class="n">signal2</span><span class="p">))</span>
    
    <span class="c1"># Calculate the n:m phase difference</span>
    <span class="n">phase_diff_nm</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">phase1</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">phase2</span>
    
    <span class="c1"># Calculate the unitary vectors whose angle is the instantaneous phase difference</span>
    <span class="n">unit_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_diff_nm</span><span class="p">)</span>
    
    <span class="c1"># Compute the length of the mean vector (mean resultant length)</span>
    <span class="n">Rn_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">unit_vectors</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">unit_vectors</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">Rn_m</span></div>


<div class="viewcode-block" id="cross_frequency_rrci"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.cross_frequency_rrci">[docs]</a><span class="k">def</span> <span class="nf">cross_frequency_rrci</span><span class="p">(</span>
    <span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">freq_peak1</span><span class="p">,</span> <span class="n">freq_peak2</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_denom</span><span class="o">=</span><span class="mi">50</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Rhythmic Ratio Coupling Index (RRCI) between two signals for cross-frequency.</span>

<span class="sd">    The function first calculates the rhythmic ratio between two peak frequencies. It then filters</span>
<span class="sd">    the two input signals around a frequency band centered on their respective peak frequencies.</span>
<span class="sd">    Finally, it calculates the rhythmic ratio coupling index (RRCI) for these filtered signals.</span>
<span class="sd">    The RRCI is a measure of how much the rhythms of the two signals, in terms of their phase information,</span>
<span class="sd">    are coupled across different frequencies. In other words, it provides a measure of phase-to-phase</span>
<span class="sd">    coupling across these frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal1 : ndarray</span>
<span class="sd">        First signal in time series.</span>
<span class="sd">    signal2 : ndarray</span>
<span class="sd">        Second signal in time series.</span>
<span class="sd">    sfreq : float</span>
<span class="sd">        Sampling frequency.</span>
<span class="sd">    freq_peak1 : float</span>
<span class="sd">        Peak frequency for the first signal.</span>
<span class="sd">    freq_peak2 : float</span>
<span class="sd">        Peak frequency for the second signal.</span>
<span class="sd">    bandwidth : float, default=1</span>
<span class="sd">        Frequency bandwidth for filtering the signals.</span>
<span class="sd">    max_denom : int, default=50</span>
<span class="sd">        The maximum denominator for the rhythmic ratio.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rrci : float</span>
<span class="sd">        Rhythmic Ratio Coupling Index between the two signals.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; signal1 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; signal2 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; sfreq = 100.0</span>
<span class="sd">    &gt;&gt;&gt; rrci = cross_frequency_rrci(signal1, signal2, sfreq, 10, 20, 2, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">freq_band1</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq_peak1</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">freq_peak1</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">freq_band2</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq_peak2</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">freq_peak2</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">rhythmic_ratio</span> <span class="o">=</span> <span class="n">compute_rhythmic_ratio</span><span class="p">(</span><span class="n">freq_peak1</span><span class="p">,</span> <span class="n">freq_peak2</span><span class="p">,</span> <span class="n">max_denom</span><span class="p">)</span>

    <span class="n">rrci</span> <span class="o">=</span> <span class="n">rhythmic_ratio_coupling_imaginary</span><span class="p">(</span>
        <span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">rhythmic_ratio</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">freq_band1</span><span class="p">,</span> <span class="n">freq_band2</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">rrci</span></div>


<div class="viewcode-block" id="compute_rhythmic_ratio"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.compute_rhythmic_ratio">[docs]</a><span class="k">def</span> <span class="nf">compute_rhythmic_ratio</span><span class="p">(</span><span class="n">freq1</span><span class="p">,</span> <span class="n">freq2</span><span class="p">,</span> <span class="n">max_denom</span><span class="p">):</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">freq1</span> <span class="o">/</span> <span class="n">freq2</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="n">max_denom</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ratio</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span> <span class="n">ratio</span><span class="o">.</span><span class="n">denominator</span></div>


<div class="viewcode-block" id="rhythmic_ratio_coupling_imaginary"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.rhythmic_ratio_coupling_imaginary">[docs]</a><span class="k">def</span> <span class="nf">rhythmic_ratio_coupling_imaginary</span><span class="p">(</span>
    <span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">rhythmic_ratio</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">freq_band1</span><span class="p">,</span> <span class="n">freq_band2</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Imaginary part of Rhythmic Ratio Coupling between two signals.</span>
<span class="sd">    From the paper : &quot;On cross-frequency phase-phase coupling between theta and gamma oscillations in the hippocampus&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal1 : ndarray</span>
<span class="sd">        First signal in time series.</span>
<span class="sd">    signal2 : ndarray</span>
<span class="sd">        Second signal in time series.</span>
<span class="sd">    rhythmic_ratio : tuple</span>
<span class="sd">        Rhythmic ratio (numerator, denominator).</span>
<span class="sd">    sfreq : float</span>
<span class="sd">        Sampling frequency.</span>
<span class="sd">    freq_band1 : tuple</span>
<span class="sd">        Frequency band for the first signal (lowcut, highcut).</span>
<span class="sd">    freq_band2 : tuple</span>
<span class="sd">        Frequency band for the second signal (lowcut, highcut).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    imaginary_part : float</span>
<span class="sd">        Imaginary part of the Rhythmic Ratio Coupling.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l_freq1</span><span class="p">,</span> <span class="n">h_freq1</span> <span class="o">=</span> <span class="n">freq_band1</span>
    <span class="n">l_freq2</span><span class="p">,</span> <span class="n">h_freq2</span> <span class="o">=</span> <span class="n">freq_band2</span>

    <span class="c1"># Filter the signals</span>
    <span class="n">filtered_signal1</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">filter_data</span><span class="p">(</span>
        <span class="n">signal1</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">l_freq1</span><span class="p">,</span> <span class="n">h_freq1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fir&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">filtered_signal2</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">filter_data</span><span class="p">(</span>
        <span class="n">signal2</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">l_freq2</span><span class="p">,</span> <span class="n">h_freq2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fir&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>

    <span class="c1"># Compute the Hilbert transform</span>
    <span class="n">analytic_signal1</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">)</span>
    <span class="n">analytic_signal2</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">filtered_signal2</span><span class="p">)</span>

    <span class="c1"># Extract instantaneous phases</span>
    <span class="n">phase1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal1</span><span class="p">)</span>
    <span class="n">phase2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal2</span><span class="p">)</span>

    <span class="c1"># Calculate the complex phase differences</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">rhythmic_ratio</span>
    <span class="n">phase_diff</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">phase1</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">phase2</span>

    <span class="c1"># Compute the mean of the complex exponential of the phase differences</span>
    <span class="n">mean_exp_phase_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_diff</span><span class="p">))</span>

    <span class="c1"># Extract the imaginary part</span>
    <span class="n">imaginary_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">mean_exp_phase_diff</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">imaginary_part</span><span class="p">)</span></div>


<div class="viewcode-block" id="HilbertHuang1D_nopeaks"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.HilbertHuang1D_nopeaks">[docs]</a><span class="k">def</span> <span class="nf">HilbertHuang1D_nopeaks</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">sf</span><span class="p">,</span>
    <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">nIMFs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">min_freq</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">max_freq</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span>
    <span class="n">precision</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">bin_spread</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span>
    <span class="n">smooth_sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Hilbert-Huang transform provides a description of how the energy</span>
<span class="sd">    or power within a signal is distributed across frequency.</span>
<span class="sd">    The distributions are based on the instantaneous frequency and</span>
<span class="sd">    amplitude of a signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array (numDataPoints,)</span>
<span class="sd">        Single time series.</span>
<span class="sd">    sf : int</span>
<span class="sd">        Sampling frequency.</span>
<span class="sd">    graph : bool, default=False</span>
<span class="sd">        Defines if a graph is generated.</span>
<span class="sd">    nIMFs : int, default=5</span>
<span class="sd">        Number of intrinsic mode functions (IMFs) to keep when</span>
<span class="sd">        Empirical Mode Decomposition (EMD) is computed.</span>
<span class="sd">    min_freq : float, default=1</span>
<span class="sd">        Minimum frequency to consider.</span>
<span class="sd">    max_freq : float, default=80</span>
<span class="sd">        Maximum frequency to consider.</span>
<span class="sd">    precision : float, default=0.1</span>
<span class="sd">        Value in Hertz corresponding to the minimal step between two</span>
<span class="sd">        frequency bins.</span>
<span class="sd">    bin_spread : str, default=&#39;log&#39;</span>

<span class="sd">        - &#39;linear&#39;</span>
<span class="sd">        - &#39;log&#39;</span>
<span class="sd">    smooth_sigma : float, default=None</span>
<span class="sd">        Sigma value for gaussian smoothing.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    IF : array (numDataPoints,nIMFs)</span>
<span class="sd">        instantaneous frequencies associated with each IMF.</span>
<span class="sd">    IP : array (numDataPoints,nIMFs)</span>
<span class="sd">        instantaneous power associated with each IMF.</span>
<span class="sd">    IA : array (numDataPoints,nIMFs)</span>
<span class="sd">        instantaneous amplitude associated with each IMF.</span>
<span class="sd">    spec : array (nIMFs, nbins)</span>
<span class="sd">        Power associated with all bins for each IMF</span>
<span class="sd">    bins : array (nIMFs, nbins)</span>
<span class="sd">        Frequency bins for each IMF</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">IMFs</span> <span class="o">=</span> <span class="n">EMD_eeg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;EMD&quot;</span><span class="p">)</span>
    <span class="n">IMFs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">IMFs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">IP</span><span class="p">,</span> <span class="n">IF</span><span class="p">,</span> <span class="n">IA</span> <span class="o">=</span> <span class="n">emd</span><span class="o">.</span><span class="n">spectra</span><span class="o">.</span><span class="n">frequency_transform</span><span class="p">(</span><span class="n">IMFs</span><span class="p">[:,</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">nIMFs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sf</span><span class="p">,</span> <span class="s2">&quot;nht&quot;</span><span class="p">)</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">min_freq</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">max_freq</span>
    <span class="n">range_hh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">range_hh</span> <span class="o">/</span> <span class="n">precision</span><span class="p">)</span>
    <span class="n">bin_size</span> <span class="o">=</span> <span class="n">range_hh</span> <span class="o">/</span> <span class="n">steps</span>
    <span class="n">edges</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">emd</span><span class="o">.</span><span class="n">spectra</span><span class="o">.</span><span class="n">define_hist_bins</span><span class="p">(</span>
        <span class="n">low</span> <span class="o">-</span> <span class="p">(</span><span class="n">bin_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">high</span> <span class="o">-</span> <span class="p">(</span><span class="n">bin_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">steps</span><span class="p">,</span> <span class="n">bin_spread</span>
    <span class="p">)</span>
    <span class="c1"># Compute the 1d Hilbert-Huang transform (power over carrier frequency)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">IMF</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">IF</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">freqs_</span><span class="p">,</span> <span class="n">spec_</span> <span class="o">=</span> <span class="n">emd</span><span class="o">.</span><span class="n">spectra</span><span class="o">.</span><span class="n">hilberthuang</span><span class="p">(</span><span class="n">IF</span><span class="p">[:,</span> <span class="n">IMF</span><span class="p">],</span> <span class="n">IA</span><span class="p">[:,</span> <span class="n">IMF</span><span class="p">],</span> <span class="n">edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">smooth_sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spec_</span> <span class="o">=</span> <span class="n">gaussian_filter1d</span><span class="p">(</span><span class="n">spec_</span><span class="p">,</span> <span class="n">smooth_sigma</span><span class="p">)</span>
        <span class="n">freqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freqs_</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec_</span><span class="p">)</span>
    <span class="n">bins_</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spec</span><span class="p">)):</span>
        <span class="n">bins_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">plot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spec</span><span class="p">)):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins_</span><span class="p">[</span><span class="n">plot</span><span class="p">],</span> <span class="n">spec</span><span class="p">[</span><span class="n">plot</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">min_freq</span><span class="p">,</span> <span class="n">max_freq</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;IA-weighted</span><span class="se">\n</span><span class="s2">Hilbert-Huang Transform&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s2">&quot;IMF-1&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-2&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-3&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-4&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-5&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-6&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-7&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">IF</span><span class="p">,</span> <span class="n">IP</span><span class="p">,</span> <span class="n">IA</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bins_</span><span class="p">)</span></div>


<div class="viewcode-block" id="EMD_time_resolved_harmonicity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.EMD_time_resolved_harmonicity">[docs]</a><span class="k">def</span> <span class="nf">EMD_time_resolved_harmonicity</span><span class="p">(</span>
    <span class="n">time_series1</span><span class="p">,</span> <span class="n">time_series2</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">nIMFs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the harmonicity between the instantaneous frequencies (IF) for each</span>
<span class="sd">    point in time between all pairs of corresponding intrinsic mode functions (IMFs).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time_series1 : array (numDataPoints,)</span>
<span class="sd">        First time series.</span>
<span class="sd">    time_series2 : array (numDataPoints,)</span>
<span class="sd">        Second time series.</span>
<span class="sd">    sf : int</span>
<span class="sd">        Sampling frequency.</span>
<span class="sd">    nIMFs : int, default=5</span>
<span class="sd">        Number of intrinsic mode functions (IMFs) to consider.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    harmonicity : array (numDataPoints, nIMFs)</span>
<span class="sd">        Harmonicity values for each pair of corresponding IMFs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Compute the Hilbert-Huang transform for each time series</span>
    <span class="n">IF1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">HilbertHuang1D_nopeaks</span><span class="p">(</span><span class="n">time_series1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">nIMFs</span><span class="o">=</span><span class="n">nIMFs</span><span class="p">)</span>
    <span class="n">IF2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">HilbertHuang1D_nopeaks</span><span class="p">(</span><span class="n">time_series2</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">nIMFs</span><span class="o">=</span><span class="n">nIMFs</span><span class="p">)</span>
    <span class="c1">#print(IF1.shape)</span>
    <span class="c1"># Compute the harmonicity between the instantaneous frequencies of corresponding IMFs</span>
    <span class="n">harmonicity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">IF1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nIMFs</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">IF1</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">imf</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIMFs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;harmsim&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">IF1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">IF2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]:</span>
                        <span class="n">harmonicity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">=</span> <span class="n">dyad_similarity</span><span class="p">(</span><span class="n">IF1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">/</span> <span class="n">IF2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">IF1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">IF2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]:</span>
                        <span class="n">harmonicity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">=</span> <span class="n">dyad_similarity</span><span class="p">(</span><span class="n">IF2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">/</span> <span class="n">IF1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                    <span class="n">harmonicity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;subharm_tension&quot;</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">subharm_tension</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_subharmonic_tension</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">IF1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">],</span> <span class="n">IF2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]],</span>
                    <span class="n">n_harmonics</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">delta_lim</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                    <span class="n">min_notes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1">#print(subharm_tension)</span>
                <span class="k">if</span> <span class="n">subharm_tenion</span> <span class="o">!=</span> <span class="s2">&quot;NaN&quot;</span><span class="p">:</span>
                    <span class="n">harmonicity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">=</span> <span class="n">subharm_tension</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
    <span class="k">return</span> <span class="n">harmonicity</span></div>

<div class="viewcode-block" id="temporal_correlation_fdr"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.temporal_correlation_fdr">[docs]</a><span class="k">def</span> <span class="nf">temporal_correlation_fdr</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the temporal correlation for each pair of electrodes and output a connectivity matrix</span>
<span class="sd">    and a matrix of FDR-corrected p-values. This function is used in the computation of the</span>
<span class="sd">    transitional harmony connectivity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like</span>
<span class="sd">        An array of shape (electrodes, samples) containing the electrode recordings.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    connectivity_matrix : ndarray</span>
<span class="sd">        A connectivity matrix of shape (electrodes, electrodes) with the temporal correlation for each pair of electrodes.</span>
<span class="sd">    fdr_corrected_pvals : ndarray</span>
<span class="sd">        A matrix of FDR-corrected p-values of shape (electrodes, electrodes).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function calculates the temporal correlation for each pair of electrodes, creating a connectivity matrix.</span>
<span class="sd">    Simultaneously, it calculates a matrix of p-values and corrects for multiple comparisons using the False Discovery Rate (FDR) method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">num_electrodes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">connectivity_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_electrodes</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">))</span>
    <span class="n">pvals_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_electrodes</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_electrodes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_electrodes</span><span class="p">):</span>
            <span class="n">data_i_masked</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">data_j_masked</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

            <span class="n">corr</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">data_i_masked</span><span class="p">,</span> <span class="n">data_j_masked</span><span class="p">,</span> <span class="n">allow_masked</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="p">)</span>  <span class="c1"># Calculate number of non-NaN data points</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span>  <span class="c1"># Degrees of freedom</span>
            <span class="n">t_val</span> <span class="o">=</span> <span class="n">corr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">df</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">corr</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># Calculate t-value</span>
            <span class="n">pval</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">t_val</span><span class="p">),</span> <span class="n">df</span><span class="p">))</span>  <span class="c1"># Calculate two-tailed p-value</span>

            <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">pvals_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr</span><span class="p">,</span> <span class="n">pval</span>

    <span class="n">pvals</span> <span class="o">=</span> <span class="n">pvals_matrix</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">fdr_corrected_pvals</span> <span class="o">=</span> <span class="n">multipletests</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fdr_bh&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">fdr_corrected_pvals</span> <span class="o">=</span> <span class="n">fdr_corrected_pvals</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">num_electrodes</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">connectivity_matrix</span><span class="p">,</span> <span class="n">fdr_corrected_pvals</span></div>


<div class="viewcode-block" id="compute_cross_spectrum_harmonicity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.compute_cross_spectrum_harmonicity">[docs]</a><span class="k">def</span> <span class="nf">compute_cross_spectrum_harmonicity</span><span class="p">(</span>
    <span class="n">signal1</span><span class="p">,</span>
    <span class="n">signal2</span><span class="p">,</span>
    <span class="n">precision_hz</span><span class="p">,</span>
    <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">noverlap</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">fs</span><span class="o">=</span><span class="mi">44100</span><span class="p">,</span>
    <span class="n">power_law_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">n_peaks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span><span class="p">,</span>
    <span class="n">n_harms</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">delta_lim</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">min_notes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">smoothness</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">smoothness_harm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">phase_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">save_fig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">save_name</span><span class="o">=</span><span class="s2">&quot;harmonic_spectrum_connectivity.png&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the cross-spectrum harmonicity between two signals. This function is useful for analyzing</span>
<span class="sd">    the interaction between frequency components of two different signals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal1, signal2 : array_like</span>
<span class="sd">        Input signals.</span>
<span class="sd">    precision_hz : float</span>
<span class="sd">        The precision in Hz for the short time Fourier transform.</span>
<span class="sd">    fmin, fmax : float or None</span>
<span class="sd">        Minimum and maximum frequency for computing the power spectral density.</span>
<span class="sd">    noverlap : int</span>
<span class="sd">        Number of points to overlap between segments for computing the power spectral density.</span>
<span class="sd">    fs : int</span>
<span class="sd">        The sampling frequency of the signals.</span>
<span class="sd">    power_law_remove : bool</span>
<span class="sd">        If True, power-law noise is removed from the power spectral densities of the signals.</span>
<span class="sd">    n_peaks : int</span>
<span class="sd">        The number of peaks to identify in the spectra.</span>
<span class="sd">    metric : {&quot;harmsim&quot;, &quot;subharm_tension&quot;}</span>
<span class="sd">        The metric to use for computing the harmonicity between the signals.</span>
<span class="sd">    n_harms : int</span>
<span class="sd">        Number of harmonics to consider for computing subharmonic tension.</span>
<span class="sd">    delta_lim : float</span>
<span class="sd">        Delta limit for computing subharmonic tension.</span>
<span class="sd">    min_notes : int</span>
<span class="sd">        Minimum number of notes for computing subharmonic tension.</span>
<span class="sd">    plot : bool</span>
<span class="sd">        If True, the function will plot the cross harmonic and phase coupling spectrum.</span>
<span class="sd">    smoothness : int</span>
<span class="sd">        Smoothness of the Fourier transform. Higher values result in a smoother transform.</span>
<span class="sd">    smoothness_harm : int</span>
<span class="sd">        Smoothness of the harmonic spectrum. Higher values result in a smoother spectrum.</span>
<span class="sd">    phase_mode : {None, &quot;weighted&quot;}</span>
<span class="sd">        If &quot;weighted&quot;, the phase coupling is computed as a weighted sum. If None, it is computed as a simple average.</span>
<span class="sd">    save_fig : bool</span>
<span class="sd">        If True, the plot is saved as a png file.</span>
<span class="sd">    save_name : str</span>
<span class="sd">        Name of the png file if save_fig is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DataFrame</span>
<span class="sd">        A pandas DataFrame with columns representing various computed metrics of the signals, such as spectral flatness, spectral entropy, etc.</span>
<span class="sd">        The DataFrame also contains columns for peak frequencies in the spectra and their harmonic similarities.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">nperseg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fs</span> <span class="o">/</span> <span class="n">precision_hz</span><span class="p">)</span>

    <span class="c1"># Compute the power spectral density for both signals</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">psd1</span> <span class="o">=</span> <span class="n">compute_frequency_and_psd</span><span class="p">(</span>
        <span class="n">signal1</span><span class="p">,</span> <span class="n">precision_hz</span><span class="p">,</span> <span class="n">smoothness</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span>
    <span class="p">)</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">psd2</span> <span class="o">=</span> <span class="n">compute_frequency_and_psd</span><span class="p">(</span>
        <span class="n">signal2</span><span class="p">,</span> <span class="n">precision_hz</span><span class="p">,</span> <span class="n">smoothness</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span>
    <span class="p">)</span>

    <span class="n">psd1_clean</span> <span class="o">=</span> <span class="n">apply_power_law_remove</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">psd1</span><span class="p">,</span> <span class="n">power_law_remove</span><span class="p">)</span>
    <span class="n">psd2_clean</span> <span class="o">=</span> <span class="n">apply_power_law_remove</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">psd2</span><span class="p">,</span> <span class="n">power_law_remove</span><span class="p">)</span>

    <span class="n">psd1_min</span><span class="p">,</span> <span class="n">psd1_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">psd1_clean</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">psd1_clean</span><span class="p">)</span>
    <span class="n">psd1_clean</span> <span class="o">=</span> <span class="p">(</span><span class="n">psd1_clean</span> <span class="o">-</span> <span class="n">psd1_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">psd1_max</span> <span class="o">-</span> <span class="n">psd1_min</span><span class="p">)</span>

    <span class="n">psd2_min</span><span class="p">,</span> <span class="n">psd2_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">psd2_clean</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">psd2_clean</span><span class="p">)</span>
    <span class="n">psd2_clean</span> <span class="o">=</span> <span class="p">(</span><span class="n">psd2_clean</span> <span class="o">-</span> <span class="n">psd2_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">psd2_max</span> <span class="o">-</span> <span class="n">psd2_min</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Zxx1</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nperseg</span> <span class="o">/</span> <span class="n">smoothness</span><span class="p">),</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Zxx2</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span><span class="n">signal2</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nperseg</span> <span class="o">/</span> <span class="n">smoothness</span><span class="p">),</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">)</span>

    <span class="n">dyad_similarities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)))</span>
    <span class="n">phase_coupling_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">freqs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">f2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">freqs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">f2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;harmsim&quot;</span><span class="p">:</span>
                    <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dyad_similarity</span><span class="p">(</span><span class="n">f1</span> <span class="o">/</span> <span class="n">f2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;subharm_tension&quot;</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">subharm</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_subharmonic_tension</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">],</span> <span class="n">n_harmonics</span><span class="o">=</span><span class="n">n_harms</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="n">delta_lim</span><span class="p">,</span> <span class="n">min_notes</span><span class="o">=</span><span class="mi">2</span>
                    <span class="p">)</span>
                    <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">subharm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Compute the wPLI</span>
                <span class="n">cross_spectrum</span> <span class="o">=</span> <span class="n">Zxx1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Zxx2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">imaginary_cross_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">cross_spectrum</span><span class="p">)</span>
                <span class="c1"># Add epsilon to the denominator</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-10</span>
                <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">imaginary_cross_spectrum</span><span class="p">)</span>
                <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">imaginary_cross_spectrum</span><span class="p">))</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="n">harmonicity_values1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
    <span class="n">harmonicity_values2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
    <span class="n">harmonicity_values_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
    <span class="n">phase_coupling_values1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
    <span class="n">phase_coupling_values2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
    <span class="n">phase_coupling_values_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>

    <span class="n">total_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psd1_clean</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psd2_clean</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)):</span>
        <span class="n">weighted_sum_harmonicity1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weighted_sum_harmonicity2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weighted_sum_harmonicity_all</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weighted_sum_phase_coupling1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weighted_sum_phase_coupling2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weighted_sum_phase_coupling_all</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">weighted_sum_harmonicity1</span> <span class="o">+=</span> <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">psd1_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">weighted_sum_harmonicity2</span> <span class="o">+=</span> <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">psd2_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd1_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">weighted_sum_harmonicity_all</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">psd1_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="o">+</span> <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">psd1_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">phase_mode</span> <span class="o">==</span> <span class="s2">&quot;weighted&quot;</span><span class="p">:</span>
                    <span class="n">weighted_sum_phase_coupling1</span> <span class="o">+=</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">psd1_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">weighted_sum_phase_coupling2</span> <span class="o">+=</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">psd2_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd1_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">weighted_sum_phase_coupling_all</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">psd1_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="o">+</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">psd1_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weighted_sum_phase_coupling1</span> <span class="o">+=</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">weighted_sum_phase_coupling2</span> <span class="o">+=</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="n">weighted_sum_phase_coupling_all</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">harmonicity_values1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_harmonicity1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">total_power</span><span class="p">)</span>
        <span class="n">harmonicity_values2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_harmonicity2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">total_power</span><span class="p">)</span>
        <span class="n">harmonicity_values_all</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_harmonicity_all</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">total_power</span><span class="p">)</span>
        <span class="n">phase_coupling_values1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_phase_coupling1</span> <span class="o">/</span> <span class="n">count</span>
        <span class="n">phase_coupling_values2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_phase_coupling2</span> <span class="o">/</span> <span class="n">count</span>
        <span class="n">phase_coupling_values_all</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_phase_coupling_all</span> <span class="o">/</span> <span class="n">count</span>

    <span class="n">harmonicity_values1</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">harmonicity_values1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span><span class="p">)</span>
    <span class="n">harmonicity_values2</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">harmonicity_values2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span><span class="p">)</span>
    <span class="n">harmonicity_values_all</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
        <span class="n">harmonicity_values_all</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span>
    <span class="p">)</span>
    <span class="n">phase_coupling_values1</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
        <span class="n">phase_coupling_values1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span>
    <span class="p">)</span>
    <span class="n">phase_coupling_values2</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
        <span class="n">phase_coupling_values2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span>
    <span class="p">)</span>
    <span class="n">phase_coupling_values_all</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
        <span class="n">phase_coupling_values_all</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span>
    <span class="p">)</span>

    <span class="c1"># Step 1: Calculate a combined metric for harmonicity and phase-coupling by multiplying normalized values</span>
    <span class="n">normalized_combined_metric</span> <span class="o">=</span> <span class="n">compute_resonance_values</span><span class="p">(</span>
        <span class="n">harmonicity_values_all</span><span class="p">,</span> <span class="n">phase_coupling_values_all</span>
    <span class="p">)</span>

    <span class="c1"># Find peaks in the spectra</span>
    <span class="n">harmonicity_peak_frequencies</span><span class="p">,</span> <span class="n">harm_peak_idx</span> <span class="o">=</span> <span class="n">find_spectral_peaks</span><span class="p">(</span>
        <span class="n">harmonicity_values_all</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">n_peaks</span><span class="p">,</span> <span class="n">prominence_threshold</span><span class="o">=</span><span class="mf">0.1</span>
    <span class="p">)</span>
    <span class="n">phase_peak_frequencies</span><span class="p">,</span> <span class="n">phase_peak_idx</span> <span class="o">=</span> <span class="n">find_spectral_peaks</span><span class="p">(</span>
        <span class="n">phase_coupling_values_all</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">n_peaks</span><span class="p">,</span> <span class="n">prominence_threshold</span><span class="o">=</span><span class="mf">0.0001</span>
    <span class="p">)</span>
    <span class="n">resonance_peak_frequencies</span><span class="p">,</span> <span class="n">res_peak_idx</span> <span class="o">=</span> <span class="n">find_spectral_peaks</span><span class="p">(</span>
        <span class="n">normalized_combined_metric</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">n_peaks</span><span class="p">,</span> <span class="n">prominence_threshold</span><span class="o">=</span><span class="mf">0.01</span>
    <span class="p">)</span>

    <span class="c1"># Compute spectral flatness and entropy values</span>
    <span class="n">harmonic_complexity</span> <span class="o">=</span> <span class="n">harmonic_entropy</span><span class="p">(</span>
        <span class="n">freqs</span><span class="p">,</span>
        <span class="n">harmonicity_values_all</span><span class="p">,</span>
        <span class="n">phase_coupling_values_all</span><span class="p">,</span>
        <span class="n">normalized_combined_metric</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># create dataframe with relevant values</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;harmonicity&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">harmonicity_values_all</span><span class="p">],</span>
            <span class="s2">&quot;phase_coupling&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">phase_coupling_values_all</span><span class="p">],</span>
            <span class="s2">&quot;resonance&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">normalized_combined_metric</span><span class="p">],</span>
            <span class="s2">&quot;harm_spectral_flatness&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Flatness&quot;</span><span class="p">][</span><span class="s2">&quot;Harmonicity&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;harm_spectral_entropy&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Entropy&quot;</span><span class="p">][</span><span class="s2">&quot;Harmonicity&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;harm_higuchi&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Higuchi Fractal Dimension&quot;</span><span class="p">][</span><span class="s2">&quot;Harmonicity&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;harm_spectral_spread&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Spread&quot;</span><span class="p">][</span><span class="s2">&quot;Harmonicity&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;phase_spectral_flatness&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Flatness&quot;</span><span class="p">][</span><span class="s2">&quot;Phase Coupling&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;phase_spectral_entropy&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Entropy&quot;</span><span class="p">][</span><span class="s2">&quot;Phase Coupling&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;phase_higuchi&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Higuchi Fractal Dimension&quot;</span><span class="p">][</span><span class="s2">&quot;Phase Coupling&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;phase_spectral_spread&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Spread&quot;</span><span class="p">][</span><span class="s2">&quot;Phase Coupling&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;res_spectral_flatness&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Flatness&quot;</span><span class="p">][</span><span class="s2">&quot;Resonance&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;res_spectral_entropy&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Entropy&quot;</span><span class="p">][</span><span class="s2">&quot;Resonance&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;res_higuchi&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Higuchi Fractal Dimension&quot;</span><span class="p">][</span><span class="s2">&quot;Resonance&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;res_spectral_spread&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Spread&quot;</span><span class="p">][</span><span class="s2">&quot;Resonance&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;harmonicity_peak_frequencies&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">harmonicity_peak_frequencies</span><span class="p">],</span>
            <span class="s2">&quot;phase_peak_frequencies&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">phase_peak_frequencies</span><span class="p">],</span>
            <span class="s2">&quot;resonance_peak_frequencies&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">resonance_peak_frequencies</span><span class="p">],</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harmonicity_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harmonicity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_coupling_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_coupling&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harmonicity_peaks_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harmonicity_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_peaks_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_peaks_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>

    <span class="c1"># save df</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">precision_hz</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;fmin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmin</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;fmax&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmax</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_weighting&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_mode</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;smooth_fft&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothness</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;smooth_harm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothness_harm</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;fs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span>

    <span class="c1"># calculate harmonic similarity between peaks</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_harmsim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">peaks_to_harmsim</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harm_harmsim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harmonicity_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">peaks_to_harmsim</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_harmsim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">peaks_to_harmsim</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harm_harmsim_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harm_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_harmsim_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_harmsim_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harm_harmsim_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harm_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_max</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_harmsim_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_max</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_harmsim_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_max</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ax4</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">psd1</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkred&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Spectrum 1&quot;</span><span class="p">)</span>
        <span class="c1"># ax1.scatter(freqs[peaks_psd1], 10 * np.log10(psd1[peaks_psd1]), color=&#39;red&#39;, marker=&#39;o&#39;, s=50)  # Add red dots on detected peaks</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">psd2</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkgoldenrod&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Spectrum 2&quot;</span><span class="p">)</span>
        <span class="c1"># ax1.scatter(freqs[peaks_psd2], 10 * np.log10(psd2[peaks_psd2]), color=&#39;red&#39;, marker=&#39;o&#39;, s=50)  # Add red dots on detected peaks</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Spectra 1 and 2&quot;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power (dB)&quot;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span>
            <span class="n">harmonicity_values1</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;mediumaquamarine&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span> <span class="n">harmonicity_values2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;turquoise&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span>
            <span class="n">harmonicity_values_all</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkblue&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Cross Harmonic Spectrum&quot;</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">harm_peak_idx</span><span class="p">],</span>
            <span class="n">harmonicity_values_all</span><span class="p">[</span><span class="n">harm_peak_idx</span><span class="p">],</span>
            <span class="s2">&quot;ro&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkblue&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Cross Harmonic and Phase Coupling Spectrum&quot;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Harmonicity&quot;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">harmonicity_peak_frequencies</span><span class="p">:</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkblue&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>

        <span class="n">ax3</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span> <span class="n">phase_coupling_values1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;violet&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span>
        <span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span>
            <span class="n">phase_coupling_values2</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;mediumorchid&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span>
            <span class="n">phase_coupling_values_all</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;indigo&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Cross Phase Coupling Spectrum&quot;</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">phase_peak_idx</span><span class="p">],</span>
            <span class="n">phase_coupling_values_all</span><span class="p">[</span><span class="n">phase_peak_idx</span><span class="p">],</span>
            <span class="s2">&quot;ro&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;indigo&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Phase Coupling&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">phase_peak_frequencies</span><span class="p">:</span>
            <span class="n">ax3</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkviolet&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>

        <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">normalized_combined_metric</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;deeppink&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Resonance&quot;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Resonance&quot;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Combined Metric&quot;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">res_peak_idx</span><span class="p">],</span>
            <span class="n">normalized_combined_metric</span><span class="p">[</span><span class="n">res_peak_idx</span><span class="p">],</span>
            <span class="s2">&quot;ro&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;deeppink&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># ax4.legend()</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">resonance_peak_frequencies</span><span class="p">:</span>
            <span class="n">ax4</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>

        <span class="c1"># Add the legend for the second y-axis (phase_coupling) plot</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">get_legend_handles_labels</span><span class="p">()</span>
        <span class="n">lines2</span><span class="p">,</span> <span class="n">labels2</span> <span class="o">=</span> <span class="n">ax3</span><span class="o">.</span><span class="n">get_legend_handles_labels</span><span class="p">()</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">lines</span> <span class="o">+</span> <span class="n">lines2</span><span class="p">,</span> <span class="n">labels</span> <span class="o">+</span> <span class="n">labels2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">save_fig</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">savename</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">df</span></div>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">def compute_mutual_information(phase1, phase2, num_bins=10):</span>
<span class="sd">    # Discretize phase values into bins</span>
<span class="sd">    discretized_phase1 = np.digitize(</span>
<span class="sd">        phase1, bins=np.linspace(-np.pi, np.pi, num_bins + 1)</span>
<span class="sd">    )</span>
<span class="sd">    discretized_phase2 = np.digitize(</span>
<span class="sd">        phase2, bins=np.linspace(-np.pi, np.pi, num_bins + 1)</span>
<span class="sd">    )</span>

<span class="sd">    # Compute the joint probability distribution of the discretized phase values</span>
<span class="sd">    joint_prob, _, _ = np.histogram2d(</span>
<span class="sd">        discretized_phase1, discretized_phase2, bins=num_bins</span>
<span class="sd">    )</span>

<span class="sd">    # Normalize the joint probability distribution</span>
<span class="sd">    joint_prob = joint_prob / np.sum(joint_prob)</span>

<span class="sd">    # Compute Mutual Information</span>
<span class="sd">    MI = mutual_info_score(None, None, contingency=joint_prob)</span>

<span class="sd">    return MI</span>


<span class="sd">def MI_spectral(</span>
<span class="sd">    signal1, signal2, sf, min_freq, max_freq, precision, peak_pairs, wavelet=&quot;cmor&quot;</span>
<span class="sd">):</span>
<span class="sd">    # Define the scales for the CWT based on the desired frequency precision</span>
<span class="sd">    scales = np.arange(min_freq, max_freq + precision, precision)</span>
<span class="sd">    scales = (sf / (2 * np.pi * precision)) * np.divide(1, scales)</span>

<span class="sd">    # Compute the Continuous Wavelet Transform of the signals</span>
<span class="sd">    cwt_signal1 = pywt.cwt(signal1, scales, wavelet)[0]</span>
<span class="sd">    cwt_signal2 = pywt.cwt(signal2, scales, wavelet)[0]</span>

<span class="sd">    # Extract the phase values from the CWT coefficients</span>
<span class="sd">    phase_signal1 = np.angle(cwt_signal1)</span>
<span class="sd">    phase_signal2 = np.angle(cwt_signal2)</span>

<span class="sd">    # Compute the Mutual Information between the phase values in the time-frequency domain</span>
<span class="sd">    mi_matrix = np.zeros((len(scales), len(scales)))</span>
<span class="sd">    for i in range(len(scales)):</span>
<span class="sd">        for j in range(len(scales)):</span>
<span class="sd">            mi_matrix[i, j] = mutual_info_score(</span>
<span class="sd">                phase_signal1[i, :], phase_signal2[j, :]</span>
<span class="sd">            )</span>

<span class="sd">    # Extract the MI values corresponding to the pairs of peaks</span>
<span class="sd">    mi_values = []</span>
<span class="sd">    for pair in peak_pairs:</span>
<span class="sd">        scale1 = int((sf / (2 * np.pi * precision)) * np.divide(1, pair[0]))</span>
<span class="sd">        scale2 = int((sf / (2 * np.pi * precision)) * np.divide(1, pair[1]))</span>
<span class="sd">        mi_values.append(mi_matrix[scale1, scale2])</span>

<span class="sd">    # Calculate the average MI value for the pairs of peaks</span>
<span class="sd">    avg_mi = np.mean(mi_values)</span>

<span class="sd">    return avg_mi&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;    def compute_harmonicity_metric_for_IMFs(data, sf, metric=&#39;harmsim&#39;, delta_lim=20, nIMFs=5, FREQ_BANDS=None):</span>
<span class="sd">        # Apply EMD to each channel</span>
<span class="sd">        emd_processor = EMD()</span>
<span class="sd">        IMFs = [emd_processor(channel)[:nIMFs] for channel in data]</span>

<span class="sd">        # Initialize variables</span>
<span class="sd">        list_idx = list(range(len(IMFs)))</span>
<span class="sd">        pairs = list(itertools.product(list_idx, list_idx))</span>
<span class="sd">        harm_conn_matrix = []</span>

<span class="sd">        if FREQ_BANDS is None:</span>
<span class="sd">            FREQ_BANDS = [</span>
<span class="sd">                [2, 3.55],</span>
<span class="sd">                [3.55, 7.15],</span>
<span class="sd">                [7.15, 14.3],</span>
<span class="sd">                [14.3, 28.55],</span>
<span class="sd">                [28.55, 49.4],</span>
<span class="sd">            ]</span>

<span class="sd">        if metric == &#39;wPLI_multiband&#39;:</span>
<span class="sd">            harm_conn_matrix = np.zeros((len(FREQ_BANDS), len(IMFs), len(IMFs)))</span>

<span class="sd">        # Compute the desired harmonicity metric for each corresponding IMF for each pair of channels</span>
<span class="sd">        for pair in pairs:</span>
<span class="sd">            imfs1 = IMFs[pair[0]]</span>
<span class="sd">            imfs2 = IMFs[pair[1]]</span>

<span class="sd">            for i in range(nIMFs):</span>
<span class="sd">                for j in range(nIMFs):</span>
<span class="sd">                    # Compute the desired harmonicity metric for the pair of IMFs</span>
<span class="sd">                    # [Replace this line with the appropriate code to compute the desired harmonicity metric for the pair of IMFs]</span>

<span class="sd">        # [Return the appropriate result]&quot;&quot;&quot;</span>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Antoine Bellemare & François Lespinasse. This documentation and code are licensed under the <a href="https://opensource.org/licenses/MIT">MIT License</a>.<br/>
  
      &copy; Copyright 2023–2024.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>